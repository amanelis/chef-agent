#! /usr/bin/ruby -i

# Author: Alex Manelis <manelis@signifyd.com>
# Synopsis: This script is ment to boot instances on AWS and configure them
#   using the Chef scripts that are part of this package. This script has
#   one optional argument. Pass a -n flag to specify how many nodes you want
#   to boot up and run chef on under the Signifyd AWS account. This script will
#   always default to using the "base" Chef script for its just configuring a 
#   base image. If the -n switch is left blank, the script will assume "1" 
#   instance to be started.
#
# Usage:
# 
# Given the following command, it will boot 2 instances and return their
# Amazon AWS EC2 instance ids.
#
#   $ bin/boot_instance -n 2

# Class patching
# Enumerable#in_parallel: allows you to parallelize work on collections.
module Enumerable
  def in_parallel
    map { |x| Thread.new { yield(x) } }.each{ |t| t.join }
  end
end

# Start by checking that there is always the two rubygem dependencies installed.
begin 
  orig_stdout = $stdout.dup
  $stdout.reopen('/dev/null', 'w')

  system("gem install aws-sdk --no-ri --no-rdoc")               unless system("gem list | grep aws-sdk")
  system("gem install net-ssh --no-ri --no-rdoc")               unless system("gem list | grep net-ssh")
ensure
  $stdout.reopen(orig_stdout)
end

# Require Ruby standard libs first.
require 'rubygems'
require 'optparse'
require 'yaml'

# Require all third party packages.
require 'aws-sdk'
require 'net/ssh'

# Require any class dependencies we have written.
require 'bin/pipeline'

# Options hash will contain all preset data for doing a valid deploy. Reference here for
# environment variables and any variable used throughout the provision/deployment.
options = {}

# If you want to supress/sync STDOUT
options[:stdout] = true

# Test mode will turn off real AWS interaction on certain work that needs to be done.
options[:test_mode] = false

# Main configuration for the nodes is specified here. 
options[:configuration] = {
  :aws => {
    :access_key_id => nil,
    :secret_access_key => nil,
    :credentials_file => '/private/signifyd/aws/credentials.yml',
    :ec2 => {
      :default_sleep_second => 300,
      :instance_count => 1,
      :instance => {
        :image_id => 'ami-971758fe',
        :key_name => 'platform',
        :security_groups => ['www'],
        :availability_zone => 'us-east-1a'
      },
      :instances => []
    }
  }
}

# Keep track of timing
options[:time] = {
  :main => {
    :start => nil,
    :finish => nil
  },
  :chef => {
    :start => nil,
    :finish => nil
  }
}

# Sync standard out
$stdout.sync = options[:stdout]

# First check and see if keys exist
if File.exists?(options[:configuration][:aws][:credentials_file]) 
  credentials = YAML::load(File.open(options[:configuration][:aws][:credentials_file], 'r'))
  
  # Set environment variables, this basically exports this to the current
  # environment in the running shell.
  ENV['EC2_ACCESS_KEY'] = credentials['aws']['access_key_id']
  ENV['EC2_SECRET_KEY'] = credentials['aws']['secret_access_key']
  
  options[:configuration][:aws][:access_key_id]     = credentials['aws']['access_key_id']
  options[:configuration][:aws][:secret_access_key] = credentials['aws']['secret_access_key']
  
  # Configure AWS
  AWS.config(:access_key_id => options[:configuration][:aws][:access_key_id], :secret_access_key => options[:configuration][:aws][:secret_access_key])
else
  puts "--------------------------------------------------------------------"
  puts "\033[22;31mCould not find a valid credential file at #{options[:configuration][:aws][:credentials_file]}\033[30m"
  puts "--------------------------------------------------------------------"
  exit 1
end

OptionParser.new do |parser|
  parser.banner = "USAGE: boot_instance [options]"
  parser.separator ""
  parser.separator "Specific options:"

  parser.on("-n", "--nodes INTEGER", "Pass the number of servers to boot up and run Chef on.") do |setting|
    begin
      setting = Integer(setting)
    rescue ArgumentError => e
      puts "--------------------------------------------------------------------"
      puts "\033[22;31mInvalid input, please give an integer only for -n/--nodes switch.#{options[:configuration][:aws][:credentials_file]}\033[30m"
      puts "--------------------------------------------------------------------"
      exit 1
    end
    
    options[:configuration][:aws][:ec2][:instance_count] = setting
  end

  parser.on_tail("-h", "--help", "--usage", "Show this usage message and quit.") do |setting|
    puts parser.help
    exit
  end
end.parse!(ARGV)

# Start timeer
options[:time][:main][:start] = Time.now

# Create a few instances to communicate with AWS
EC2 = AWS::EC2.new
ELB = AWS::ELB.new
AS3 = AWS::S3.new

# Iterate for x times to create number of instances
puts "Booting #{options[:configuration][:aws][:ec2][:instance_count]} AWS instance(s)..."
options[:configuration][:aws][:ec2][:instance_count].times.collect { |ndx| 
  instance = EC2.instances.create(options[:configuration][:aws][:ec2][:instance])
  options[:configuration][:aws][:ec2][:instances] << instance
}

# Sleep and wait for currently booting images to be ready
sleep 2 while options[:configuration][:aws][:ec2][:instances].any? { |i| i.status == :pending if i.respond_to?(:status) }
puts "Sleeping #{options[:configuration][:aws][:ec2][:default_sleep_second]/60} minutes to wait for instance to fully boot and respond to ssh..."
sleep options[:configuration][:aws][:ec2][:default_sleep_second]

# Run through instances and start SSH
puts "Running Chef on all instances created..."
options[:time][:chef][:start] = Time.now
options[:configuration][:aws][:ec2][:instances].in_parallel { |instance| 
  puts "SSH into #{instance.dns_name} from Thread[#{Thread.current.object_id}]"
  Net::SSH.start(instance.dns_name, 'ec2-user') do |session|
    puts " => running Chef on #{instance.id} from Thread[#{Thread.current.object_id}]"
    session.open_channel do |ch|
      ch.request_pty
      ch.exec 'sudo sh -c "cd /root; curl -L https://raw.github.com/amanelis/chef-agent/play/install_amzn1.sh | bash -s base"'
    end 
  end
}
options[:time][:chef][:finish] = ((Time.now - options[:time][:chef][:start]) / 60).round(2)
options[:time][:main][:finish] = ((Time.now - options[:time][:main][:start]) / 60).round(2)

puts options[:configuration][:aws][:ec2][:instances].collect { |i| i.id }
puts "Completed[Chef] in #{options[:time][:chef][:finish]} minutes."
puts "Completed[Main] in #{options[:time][:main][:finish]} minutes."