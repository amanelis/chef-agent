#! /usr/bin/ruby -i

# Author: Alex Manelis <manelis@signifyd.com>
# Description: This script is ment to do one thing. Take a list of AWS EC2 instance
#   prepare and install the build that is passed in by -b onto the instace
#   ids and add them to a given load balancer. Baiscally it can be done 2 ways. 
# 
# To start, there are two required switches that must be passed.
#   -l/--loadbalancer => require a valid loadbalancer to be given.
#   -e/--environment  => require the given environment to start play.
#
# Once these two switches are enabled, you can do one of the following ways.
#
# 1) Pass instances via STDIN, one on each line as follows:
# i-8rhfjsk3
# i-208gh420
# and this script will grab those and add them to the instances array, there for
# making the -i/--instances flag optional. As for you can still manually pass in
# instances using that flag and they will get added to the instances array under
# the options hash.
#
# 2) Pass instances via the -i/--instances switch. Be sure they are in a comma
# seperated list with no spaces as follows:
# -i i-8rhfjsk3,i-208gh420
# This will then add these instances to the options instances array
#
# From this point, everything will be valid if you have these three options set.
# 
# Examples:
# Running via the first option number #1
#   Given command (boot_instance) will create 2 instances and then pipe the 
#   EC2 instance IDs into
#   
#   $ bin/boot_instance -n 2 | bin/deploy_instance -l aws.staging -b build_url
# 
#   Given command (boot_instance) will enable 2 instances with their build
#   $ bin/deploy_instance -l aws.staging -b build_url -i i-2408hg,i-f02fhf
#
# bin/boot_instance | bin/deploy_instance -l platform-test-branch -b https://s3.amazonaws.com/com.signifyd.test/platform-builds/45/

# Class patching
# Enumerable#in_parallel: allows you to parallelize work on collections.
module Enumerable
  def in_parallel
    map{ |x| Thread.new { yield(x) } }.each{ |t| t.join }
  end
end

# Start by checking that there is always the two rubygem dependencies installed.
begin 
  orig_stdout = $stdout.dup
  $stdout.reopen('/dev/null', 'w')

  system("gem install aws-sdk --no-ri --no-rdoc")               unless system("gem list | grep aws-sdk")
  system("gem install net-ssh --no-ri --no-rdoc")               unless system("gem list | grep net-ssh")
ensure
  $stdout.reopen(orig_stdout)
end

# Require Ruby standard libs first.
require 'rubygems'
require 'optparse'
require 'timeout'
require 'yaml'

# Require all third party packages.
require 'aws-sdk'
require 'net/ssh'

# Options hash will contain all preset data for doing a valid deploy. Reference here for
# environment variables and any variable used throughout the provision/deployment.
options = {}

# Well always assume 'test' env unless specified otherwise
options[:env] = :test

# If you want to supress/sync STDOUT
options[:stdout] = true

# Test mode will turn off real AWS interaction on certain work that needs to be done.
options[:test_mode] = false

####################### VERY IMPORTANT OPTIONS ####################### 
options[:commands] = {
  :swap => false,
  :register => false
}
####################### VERY IMPORTANT OPTIONS ####################### 

# Main configuration for the nodes is specified here. 
options[:configuration] = {
  :aws => {
    :access_key_id => nil,
    :secret_access_key => nil,
    :credentials_file => '/private/signifyd/aws/aws-credentials.yml',
    :elb => nil,
    :ec2 => {
      :current   => [],
      :instances => []
    },
    :s3 => {
      :bucket       => nil,
      :build_number => nil,
      :build_path   => nil,
      :build_url    => nil
    }
  },
  :play => {
    :build_hash       => {},
    :build_directory  => nil,
    :deploy_directory => '/opt/play/releases'
  }
}

# Keep track of timing
options[:time] = {
  :main => {
    :start => nil,
    :finish => nil
  },
  :build => {
    :start => nil,
    :finish => nil
  }
}

# First check and see if keys exist to make a valid AWS connection. It will exit here
# if no keys are found and/or if authentication fails.
if File.exists?(options[:configuration][:aws][:credentials_file]) 
  credentials = YAML::load(File.open(options[:configuration][:aws][:credentials_file], 'r'))
  
  # Set environment variables, this basically exports this to the current
  # environment in the running shell.
  ENV['EC2_ACCESS_KEY'] = credentials['aws']['access_key_id']
  ENV['EC2_SECRET_KEY'] = credentials['aws']['secret_access_key']
  
  options[:configuration][:aws][:access_key_id]     = credentials['aws']['access_key_id']
  options[:configuration][:aws][:secret_access_key] = credentials['aws']['secret_access_key']
  
  # Configure AWS
  AWS.config(:access_key_id => options[:configuration][:aws][:access_key_id], :secret_access_key => options[:configuration][:aws][:secret_access_key])
else
  puts "--------------------------------------------------------------------"
  puts "\033[22;31mCould not find a valid credential file at #{options[:configuration][:aws][:credentials_file]}\033[30m"
  puts "--------------------------------------------------------------------"
  exit 1
end

# Capture STDIN here and parse out if STDIN contains node information. This block of code 
# is important, if we decided to pipe( | ) data into this script, we will need to configure
# and store it from here.
unless $stdin.tty?
  $stdin.each_line do |line|
    # Save any STDIN input that contains or looks like an AWS instance ID => i-12345678
    options[:configuration][:aws][:ec2][:instances] << line.strip if line.strip =~ /^i-([a-zA-Z0-9]{8})$/ 
  end
  
  # Be sure all instances added are uniq
  options[:configuration][:aws][:ec2][:instances] = options[:configuration][:aws][:ec2][:instances].uniq
end

# Build a few objets we will need in OptionParser and throughout the script.
EC2 = AWS::EC2.new
ELB = AWS::ELB.new
AS3 = AWS::S3.new

# Get all load balancers and EC2 instances under account.
load_balancers = ELB.load_balancers
ec2_instances  = EC2.instances

OptionParser.new do |parser|
  parser.banner = "USAGE: boot_instance [options]"
  parser.separator ""
  parser.separator "Specific options:"
  
  parser.on("-i", "--instances ARRAY", Array, "\033[32mRequired\033[30m. Pass a comma seperated list of EC2 instance ids that will be booted with build. \033[31mDO NOT PUT SPACES BETWEEN IDS AND COMMAS\033[30m") do |setting|
    unless setting.empty?
      setting.collect { |instance_id| 
        next if options[:configuration][:aws][:ec2][:instances].include?(instance_id)
        options[:configuration][:aws][:ec2][:instances] << instance_id
      }
    end
  end
  
  parser.on("-b", "--buildurl S3_URL_TO_BUILD", "\033[32mRequired\033[30m. Pass the S3 url to the exact build that will be launched on new instance(s).") do |setting|
    if setting.nil?
      puts "You passed in invalid argument for switch: -b | --buildurl, please try again."
      exit 1
    else
      if setting =~ /^https:\/\/s3.amazonaws.com\/com.signifyd.(.*)\/platform-builds\/(\d){1,15}(\/)?$/
        full_build_url = setting.strip.dup
        
        bucket_path   = full_build_url.gsub(/^https:\/\/s3.amazonaws.com\//, '').gsub(/\/(.*)/, '').strip                     # "com.signifyd.prod"
        environment   = full_build_url.gsub(/^https:\/\/s3.amazonaws.com\/com.signifyd\./, '').gsub(/\/(.*)$/, '').strip      # "prod"
        build_number  = full_build_url.gsub(/^https:\/\/s3.amazonaws.com\/(.*)\/platform-builds\//, '').gsub('/', '').strip   # "149"
        
        options[:configuration][:aws][:s3][:bucket]       = bucket_path
        options[:configuration][:aws][:s3][:build_number] = build_number
        options[:configuration][:aws][:s3][:build_url]    = full_build_url
        options[:configuration][:aws][:s3][:build_path]   = "platform-builds/#{build_number}"
        
        # Ful directory where the current build will be stored
        options[:configuration][:play][:build_directory]  = "#{options[:configuration][:play][:deploy_directory]}/build-#{options[:configuration][:aws][:s3][:build_number]}" 
                
        # Build temp urls for all objects
        platform_build_url    = AS3.buckets[bucket_path].objects["#{options[:configuration][:aws][:s3][:build_path]}/signifydplatform-1.0-SNAPSHOT.zip"].url_for(
          :read,
          :expires_in => 10 * 60
        )
        platform_javaopts_url = AS3.buckets[bucket_path].objects["#{options[:configuration][:aws][:s3][:build_path]}/java_opts"].url_for(
          :read,
          :expires_in => 10 * 60
        )
        platform_newrelic_url = AS3.buckets[bucket_path].objects["#{options[:configuration][:aws][:s3][:build_path]}/newrelic.yml"].url_for(
          :read,
          :expires_in => 10 * 60
        )
        
        # Build hash, will be used during ssh to configure the files and download them
        options[:configuration][:play][:build_hash] = {
          :build => {
            :location   => "#{options[:configuration][:aws][:s3][:build_path]}/signifydplatform-1.0-SNAPSHOT.zip",
            :name       => 'signifydplatform-1.0-SNAPSHOT.zip',
            :url        => {
              :location => platform_build_url.to_s.gsub(/\?(.*)$/, '').strip,
              :params   => platform_build_url.to_s.gsub(/^(.*)\?/, '').strip
            }
          },
          :javaopts => {
            :location   => "#{options[:configuration][:aws][:s3][:build_path]}/java_opts",
            :name       => 'java_opts',
            :url        => {
              :location => platform_javaopts_url.to_s.gsub(/\?(.*)$/, '').strip,
              :params   => platform_javaopts_url.to_s.gsub(/^(.*)\?/, '').strip
            }
          },
          :newrelic => {
            :location   => "#{options[:configuration][:aws][:s3][:build_path]}/newrelic.yml",
            :name       => "newrelic.yml",
            :url        => {
              :location => platform_newrelic_url.to_s.gsub(/\?(.*)$/, '').strip,
              :params   => platform_newrelic_url.to_s.gsub(/^(.*)\?/, '').strip
            }
          }
        }
        
        # Not really needed, but good to have the env of the current build just on hand
        case environment
        when "prod"
          options[:env] = :production
        when "staging"
          options[:env] = :staging
        end
      else
        puts "Must be a valid S3 url for switch: -b | --buildurl, please try again. Follow the format below"
        puts "  "
        exit 1
      end
    end
  end

  parser.on("-l", "--loadbalancer LOAD_BALANCER", "\033[35mOptional\033[30m. Pass the load balancer (AWS NAME) the nodes will be added to.") do |setting|
    if setting.nil?
      puts "You passed in invalid argument for switch: -l | --loadbalancer, please try again."
      exit 1
    else
      if load_balancers.collect(&:name).include?(setting.strip)
        options[:configuration][:aws][:elb] = load_balancers[setting.strip]
      else
        puts "Your argument (\033[35m#{setting}\033[30m) for -l | --loadbalancer was not found under the AWS account connected, please try again."
        exit 1
      end
    end
  end
  
  parser.on("-r", "--register", "\033[35mOptional\033[30m. Adds the output nodes to given elb.") do |setting|
    options[:commands][:register] = true
  end
  
  parser.on("-s", "--swap", "\033[35mOptional\033[30m. Swaps all instances in elb with new ones created.") do |setting|
    options[:commands][:register] = true
  end
  
  parser.on("-t", "--test", "\033[35mOptional\033[30m. Enable test environment and don't do any instance work.") do |setting|
    options[:test_mode] = true
  end

  parser.on_tail("-h", "--help", "--usage", "\033[36mHelp\033[30m. Show this usage message and quit.") do |setting|
    puts parser.help
    exit 1
  end
end.parse!(ARGV)

# Sync standard out
$stdout.sync = options[:stdout]

# Start timeer
options[:time][:main][:start] = Time.now

# Must pass at least one option for elb, either --register or --swap
if options[:commands][:register] == false || options[:commands][:swap] == false
  puts "No valid '\033[22;31m-r/--register OR -s/--swap\033[30m' passed. You must choose one action to give to server."
  exit 1
end

# Check for a valid build number that should have been passed to the script
if options[:configuration][:aws][:s3][:bucket].nil? || options[:configuration][:aws][:s3][:build_number].nil? || 
   options[:configuration][:aws][:s3][:build_path].nil? || options[:configuration][:aws][:s3][:build_url].nil?
  puts "No valid '\033[22;31m-b OR --buildurl\033[30m' passed. You must pass the S3 buildurl to the build you want installed on the servers."
  exit 1
end

# Check for nil or empty instances, if they are empty, we will boot number of instances in load balancer.
# If there are no instances in load balancer, code will boot 1 instance to start with.
if options[:configuration][:aws][:ec2][:instances].empty? || options[:configuration][:aws][:ec2][:instances].nil?
  # This means no servers were passed in via STDIN or cmd line arguments, lets create some based on loadbalancer
  number_of_instances = 0
  number_of_instances = options[:configuration][:aws][:elb].instances.count unless options[:configuration][:aws][:elb].instances.nil?
  number_of_instances = 2 if number_of_instances == 0
  
  puts "Calling $ bin/boot_instance -n #{number_of_instances}"
  create_instances = `./bin/boot_instance -n #{number_of_instances}`.strip
  
  # Now parse out instances created
  temp_instances = create_instances.split(/\r?\n/).collect(&:strip).reject { |i| i.nil? || i == "" }
  
  # Iterate through all STDIN entries and find the one that matches an instance
  temp_instances.each do |line_instance|
    if line_instance =~ /^i-([a-zA-Z0-9]{8})$/ 
      options[:configuration][:aws][:ec2][:instances] << line_instance
    end
  end
  
  # Now source the real instance IDs and replace string IDs with real AWS instances
  ec2_instance_ids = ec2_instances.collect(&:id) unless options[:test_mode]
  options[:configuration][:aws][:ec2][:instances] = options[:configuration][:aws][:ec2][:instances].inject([]) { |a, i|
    next a unless ec2_instance_ids.include?(i)
    a << EC2.instances[i]
  } unless options[:test_mode]
else 
  # Source instances in instance array and checks to see if instances passed via STDIN are actually in AWS account. For testing, included the --test
  # flag as an cmd line argument and it won't check the account for valid instances
  ec2_instance_ids = ec2_instances.collect(&:id)
  options[:configuration][:aws][:ec2][:instances] = options[:configuration][:aws][:ec2][:instances].inject([]) { |a, i|
    next a unless ec2_instance_ids.include?(i)
    a << EC2.instances[i]
  } unless options[:test_mode]
  
  if options[:configuration][:aws][:ec2][:instances].nil? || options[:configuration][:aws][:ec2][:instances].empty?
    puts "\033[35mThe configuration set has no valid AWS instances, so it cannot continue.\033[30m"
    puts "\033[35mCheck the AWS instance IDs that are being passed in via STDIN and be sure\033[30m"
    puts "\033[35mthey match valid AWS IDs in the account specified by AWS credential keys.\033[30m"
    exit 1
  end
end

# Build instructions to be run on the server, this is very important.
instructions = [
  "/bin/rm -rf #{options[:configuration][:play][:build_directory]}/",
  "/bin/mkdir #{options[:configuration][:play][:build_directory]}/",
  "/bin/touch #{options[:configuration][:play][:build_directory]}/play.log",
  "/usr/bin/curl -G -d '#{options[:configuration][:play][:build_hash][:build][:url][:params]}' #{options[:configuration][:play][:build_hash][:build][:url][:location]} -o #{options[:configuration][:play][:build_directory]}/#{options[:configuration][:play][:build_hash][:build][:name]}",
  "/usr/bin/curl -G -d '#{options[:configuration][:play][:build_hash][:javaopts][:url][:params]}' #{options[:configuration][:play][:build_hash][:javaopts][:url][:location]} -o #{options[:configuration][:play][:build_directory]}/#{options[:configuration][:play][:build_hash][:javaopts][:name]}",
  "/usr/bin/curl -G -d '#{options[:configuration][:play][:build_hash][:newrelic][:url][:params]}' #{options[:configuration][:play][:build_hash][:newrelic][:url][:location]} -o #{options[:configuration][:play][:build_directory]}/#{options[:configuration][:play][:build_hash][:newrelic][:name]}",
  "/usr/bin/unzip #{options[:configuration][:play][:build_directory]}/#{options[:configuration][:play][:build_hash][:build][:name]} -d #{options[:configuration][:play][:build_directory]}/",
  "/bin/rm -rf #{options[:configuration][:play][:build_directory]}/*.zip",
  "/bin/ln -nsf #{options[:configuration][:play][:build_directory]}/ /opt/play/current",
  "/usr/bin/sudo stop platform",
  "/usr/bin/sudo start platform EMAIL_ALERT_FREQUENCY=0"
]

# Break out Threads to work on each instance, ssh and configure using the instructions []
puts "Running Build on all instances created..."
options[:time][:build][:start] = Time.now
options[:configuration][:aws][:ec2][:instances].collect { |instance| 
  # Tag the instances to the current env
  instance.add_tag('Name', :value => "platform-#{options[:env].to_s}-#{options[:configuration][:aws][:s3][:build_number]}")
  
  # Do the work via SSH
  puts "SSH into #{instance.dns_name} from Thread[#{Thread.current.object_id}]"
  Net::SSH.start(instance.dns_name, 'play') do |session|
    puts " => running Instructions on #{instance.id} from Thread[#{Thread.current.object_id}]"
    instructions.each do |instruction|
      session.exec instruction
      session.loop
    end
  end
  
  # Waiting for play to start, then exit
  wait_count = 0
  puts "Waiting for play to start at #{instance.dns_name}, querying application every 2 seconds from Thread[#{Thread.current.object_id}]"
  while true
    puts " -> sleeping for 2 minutes on count[#{wait_count}] from Thread[#{Thread.current.object_id}]"
    sleep 120
    
    # Watch for Timeout
    begin 
      response = Timeout.timeout(10) do
        `curl -Is http://#{instance.dns_name} | grep -c 303`.strip
      end
    rescue Timeout::Error => e
      puts "Timeout::Error => #{e}"
      puts "Timeout on starting play for #{instance.dns_name} from Thread[#{Thread.current.object_id}]"
      puts "Please remove instances #{options[:configuration][:aws][:ec2][:instances].collect(&:id).join(',')}"
      exit 1
    end
    
    if response == 1 || response == "1"
      puts ""
      break
    end
    
    if wait_count == 3
      puts "Wait_count hit[#{wait_count}] starting play for #{instance.dns_name} from Thread[#{Thread.current.object_id}]"
      puts "Terminating instance[#{instance.id}]"
      
      # Remove instance
      options[:configuration][:aws][:ec2][:instances].delete(instance)
      
      # Terminate it from AWS account
      instance.terminate
      break
    end
    
    # Increment wait_count
    wait_count +=1
  end
}

puts "Threads have completed work on instances, moving to register/swap..."

# Swap instances
if options[:configuration][:aws][:elb] && options[:commands][:swap]
  # Swap instances on load balancer with newly created instances only if there are instances 
  puts "Swapping instances on loadbalancer[#{options[:configuration][:aws][:elb].name}] now..."
  puts "Calling $ bin/swap_instance -l #{options[:configuration][:aws][:elb].name} -i #{options[:configuration][:aws][:ec2][:instances].collect(&:id).join(',')}"
  swap_instances = `./bin/swap_instance -l #{options[:configuration][:aws][:elb].name} -i #{options[:configuration][:aws][:ec2][:instances].collect(&:id).join(',')}`
elsif options[:configuration][:aws][:elb] && options[:commands][:register]
  # Registering new instances
  puts "Registering instances on loadbalancer[#{options[:configuration][:aws][:elb].name}] now..."
  puts "Calling $ bin/register_instance -l #{options[:configuration][:aws][:elb].name} -i #{options[:configuration][:aws][:ec2][:instances].collect(&:id).join(',')}"
end

options[:time][:build][:finish] = ((Time.now - options[:time][:build][:start]) / 60).round(2)
options[:time][:main][:finish]  = ((Time.now - options[:time][:main][:start]) / 60).round(2)

puts options[:configuration][:aws][:ec2][:instances].collect { |i| i.id }
puts "Completed[Build] in #{options[:time][:build][:finish]} minutes."
puts "Completed[Main] in #{options[:time][:main][:finish]} minutes."